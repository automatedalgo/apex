// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GxWireFormat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_GxWireFormat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_GxWireFormat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GxWireFormat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_GxWireFormat_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_GxWireFormat_2eproto;
namespace apex {
namespace pb {
class CancelOrder;
struct CancelOrderDefaultTypeInternal;
extern CancelOrderDefaultTypeInternal _CancelOrder_default_instance_;
class CancelOrderReply;
struct CancelOrderReplyDefaultTypeInternal;
extern CancelOrderReplyDefaultTypeInternal _CancelOrderReply_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class LogonReply;
struct LogonReplyDefaultTypeInternal;
extern LogonReplyDefaultTypeInternal _LogonReply_default_instance_;
class LogonRequest;
struct LogonRequestDefaultTypeInternal;
extern LogonRequestDefaultTypeInternal _LogonRequest_default_instance_;
class NewOrder;
struct NewOrderDefaultTypeInternal;
extern NewOrderDefaultTypeInternal _NewOrder_default_instance_;
class OmLogonReply;
struct OmLogonReplyDefaultTypeInternal;
extern OmLogonReplyDefaultTypeInternal _OmLogonReply_default_instance_;
class OmLogonRequest;
struct OmLogonRequestDefaultTypeInternal;
extern OmLogonRequestDefaultTypeInternal _OmLogonRequest_default_instance_;
class OrderExecution;
struct OrderExecutionDefaultTypeInternal;
extern OrderExecutionDefaultTypeInternal _OrderExecution_default_instance_;
class OrderFill;
struct OrderFillDefaultTypeInternal;
extern OrderFillDefaultTypeInternal _OrderFill_default_instance_;
class SubscribeTicks;
struct SubscribeTicksDefaultTypeInternal;
extern SubscribeTicksDefaultTypeInternal _SubscribeTicks_default_instance_;
class SubscribeWallet;
struct SubscribeWalletDefaultTypeInternal;
extern SubscribeWalletDefaultTypeInternal _SubscribeWallet_default_instance_;
class TickTop;
struct TickTopDefaultTypeInternal;
extern TickTopDefaultTypeInternal _TickTop_default_instance_;
class TickTrade;
struct TickTradeDefaultTypeInternal;
extern TickTradeDefaultTypeInternal _TickTrade_default_instance_;
class WalletUpdate;
struct WalletUpdateDefaultTypeInternal;
extern WalletUpdateDefaultTypeInternal _WalletUpdate_default_instance_;
}  // namespace pb
}  // namespace apex
PROTOBUF_NAMESPACE_OPEN
template<> ::apex::pb::CancelOrder* Arena::CreateMaybeMessage<::apex::pb::CancelOrder>(Arena*);
template<> ::apex::pb::CancelOrderReply* Arena::CreateMaybeMessage<::apex::pb::CancelOrderReply>(Arena*);
template<> ::apex::pb::Error* Arena::CreateMaybeMessage<::apex::pb::Error>(Arena*);
template<> ::apex::pb::LogonReply* Arena::CreateMaybeMessage<::apex::pb::LogonReply>(Arena*);
template<> ::apex::pb::LogonRequest* Arena::CreateMaybeMessage<::apex::pb::LogonRequest>(Arena*);
template<> ::apex::pb::NewOrder* Arena::CreateMaybeMessage<::apex::pb::NewOrder>(Arena*);
template<> ::apex::pb::OmLogonReply* Arena::CreateMaybeMessage<::apex::pb::OmLogonReply>(Arena*);
template<> ::apex::pb::OmLogonRequest* Arena::CreateMaybeMessage<::apex::pb::OmLogonRequest>(Arena*);
template<> ::apex::pb::OrderExecution* Arena::CreateMaybeMessage<::apex::pb::OrderExecution>(Arena*);
template<> ::apex::pb::OrderFill* Arena::CreateMaybeMessage<::apex::pb::OrderFill>(Arena*);
template<> ::apex::pb::SubscribeTicks* Arena::CreateMaybeMessage<::apex::pb::SubscribeTicks>(Arena*);
template<> ::apex::pb::SubscribeWallet* Arena::CreateMaybeMessage<::apex::pb::SubscribeWallet>(Arena*);
template<> ::apex::pb::TickTop* Arena::CreateMaybeMessage<::apex::pb::TickTop>(Arena*);
template<> ::apex::pb::TickTrade* Arena::CreateMaybeMessage<::apex::pb::TickTrade>(Arena*);
template<> ::apex::pb::WalletUpdate* Arena::CreateMaybeMessage<::apex::pb::WalletUpdate>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apex {
namespace pb {

enum Side : int {
  side_none = 0,
  side_buy = 1,
  side_sell = 2,
  Side_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Side_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Side_IsValid(int value);
constexpr Side Side_MIN = side_none;
constexpr Side Side_MAX = side_sell;
constexpr int Side_ARRAYSIZE = Side_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Side_descriptor();
template<typename T>
inline const std::string& Side_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Side>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Side_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Side_descriptor(), enum_t_value);
}
inline bool Side_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Side* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Side>(
    Side_descriptor(), name, value);
}
enum Exchange : int {
  exchange_none = 0,
  exchange_binance = 1,
  exchange_binance_usdfut = 2,
  exchange_binance_coinfut = 3,
  Exchange_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Exchange_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Exchange_IsValid(int value);
constexpr Exchange Exchange_MIN = exchange_none;
constexpr Exchange Exchange_MAX = exchange_binance_coinfut;
constexpr int Exchange_ARRAYSIZE = Exchange_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Exchange_descriptor();
template<typename T>
inline const std::string& Exchange_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Exchange>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Exchange_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Exchange_descriptor(), enum_t_value);
}
inline bool Exchange_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Exchange* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Exchange>(
    Exchange_descriptor(), name, value);
}
enum RunMode : int {
  runmode_none = 0,
  runmode_sim = 1,
  runmode_live = 2,
  RunMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RunMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RunMode_IsValid(int value);
constexpr RunMode RunMode_MIN = runmode_none;
constexpr RunMode RunMode_MAX = runmode_live;
constexpr int RunMode_ARRAYSIZE = RunMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RunMode_descriptor();
template<typename T>
inline const std::string& RunMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RunMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RunMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RunMode_descriptor(), enum_t_value);
}
inline bool RunMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RunMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RunMode>(
    RunMode_descriptor(), name, value);
}
enum OrderState : int {
  orderstate_none = 0,
  orderstate_init = 1,
  orderstate_submitted = 2,
  orderstate_live = 3,
  orderstate_closed = 4,
  OrderState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderState_IsValid(int value);
constexpr OrderState OrderState_MIN = orderstate_none;
constexpr OrderState OrderState_MAX = orderstate_closed;
constexpr int OrderState_ARRAYSIZE = OrderState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderState_descriptor();
template<typename T>
inline const std::string& OrderState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderState_descriptor(), enum_t_value);
}
inline bool OrderState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderState>(
    OrderState_descriptor(), name, value);
}
enum CloseReason : int {
  closereason_none = 0,
  closereason_expired = 1,
  closereason_rejected = 2,
  closereason_canceled = 3,
  closereason_filled = 4,
  CloseReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CloseReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CloseReason_IsValid(int value);
constexpr CloseReason CloseReason_MIN = closereason_none;
constexpr CloseReason CloseReason_MAX = closereason_filled;
constexpr int CloseReason_ARRAYSIZE = CloseReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloseReason_descriptor();
template<typename T>
inline const std::string& CloseReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CloseReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CloseReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CloseReason_descriptor(), enum_t_value);
}
inline bool CloseReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CloseReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CloseReason>(
    CloseReason_descriptor(), name, value);
}
enum OrderType : int {
  ordertype_none = 0,
  ordertype_limit = 1,
  ordertype_market = 2,
  OrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderType_IsValid(int value);
constexpr OrderType OrderType_MIN = ordertype_none;
constexpr OrderType OrderType_MAX = ordertype_market;
constexpr int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderType_descriptor();
template<typename T>
inline const std::string& OrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderType_descriptor(), enum_t_value);
}
inline bool OrderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
enum OrderUpdateReason : int {
  UNSOLICITED = 0,
  NEW_ORDER_ACK = 1,
  CANCEL_ORDER_ACK = 2,
  OrderUpdateReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OrderUpdateReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OrderUpdateReason_IsValid(int value);
constexpr OrderUpdateReason OrderUpdateReason_MIN = UNSOLICITED;
constexpr OrderUpdateReason OrderUpdateReason_MAX = CANCEL_ORDER_ACK;
constexpr int OrderUpdateReason_ARRAYSIZE = OrderUpdateReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OrderUpdateReason_descriptor();
template<typename T>
inline const std::string& OrderUpdateReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OrderUpdateReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OrderUpdateReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OrderUpdateReason_descriptor(), enum_t_value);
}
inline bool OrderUpdateReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OrderUpdateReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderUpdateReason>(
    OrderUpdateReason_descriptor(), name, value);
}
// ===================================================================

class LogonRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:apex.pb.LogonRequest) */ {
 public:
  inline LogonRequest() : LogonRequest(nullptr) {}
  explicit constexpr LogonRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogonRequest(const LogonRequest& from);
  LogonRequest(LogonRequest&& from) noexcept
    : LogonRequest() {
    *this = ::std::move(from);
  }

  inline LogonRequest& operator=(const LogonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogonRequest& operator=(LogonRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogonRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogonRequest* internal_default_instance() {
    return reinterpret_cast<const LogonRequest*>(
               &_LogonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogonRequest& a, LogonRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogonRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogonRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogonRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogonRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LogonRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LogonRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.LogonRequest";
  }
  protected:
  explicit LogonRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apex.pb.LogonRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class LogonReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.LogonReply) */ {
 public:
  inline LogonReply() : LogonReply(nullptr) {}
  ~LogonReply() override;
  explicit constexpr LogonReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogonReply(const LogonReply& from);
  LogonReply(LogonReply&& from) noexcept
    : LogonReply() {
    *this = ::std::move(from);
  }

  inline LogonReply& operator=(const LogonReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogonReply& operator=(LogonReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogonReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogonReply* internal_default_instance() {
    return reinterpret_cast<const LogonReply*>(
               &_LogonReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LogonReply& a, LogonReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LogonReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogonReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogonReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogonReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogonReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogonReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogonReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.LogonReply";
  }
  protected:
  explicit LogonReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.LogonReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class OmLogonRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.OmLogonRequest) */ {
 public:
  inline OmLogonRequest() : OmLogonRequest(nullptr) {}
  ~OmLogonRequest() override;
  explicit constexpr OmLogonRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OmLogonRequest(const OmLogonRequest& from);
  OmLogonRequest(OmLogonRequest&& from) noexcept
    : OmLogonRequest() {
    *this = ::std::move(from);
  }

  inline OmLogonRequest& operator=(const OmLogonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OmLogonRequest& operator=(OmLogonRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OmLogonRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OmLogonRequest* internal_default_instance() {
    return reinterpret_cast<const OmLogonRequest*>(
               &_OmLogonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OmLogonRequest& a, OmLogonRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OmLogonRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OmLogonRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OmLogonRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OmLogonRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OmLogonRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OmLogonRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OmLogonRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.OmLogonRequest";
  }
  protected:
  explicit OmLogonRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrategyIdFieldNumber = 2,
    kRunModeFieldNumber = 1,
  };
  // string strategy_id = 2;
  void clear_strategy_id();
  const std::string& strategy_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_strategy_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_strategy_id();
  PROTOBUF_NODISCARD std::string* release_strategy_id();
  void set_allocated_strategy_id(std::string* strategy_id);
  private:
  const std::string& _internal_strategy_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_strategy_id(const std::string& value);
  std::string* _internal_mutable_strategy_id();
  public:

  // .apex.pb.RunMode run_mode = 1;
  void clear_run_mode();
  ::apex::pb::RunMode run_mode() const;
  void set_run_mode(::apex::pb::RunMode value);
  private:
  ::apex::pb::RunMode _internal_run_mode() const;
  void _internal_set_run_mode(::apex::pb::RunMode value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.OmLogonRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr strategy_id_;
  int run_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class OmLogonReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.OmLogonReply) */ {
 public:
  inline OmLogonReply() : OmLogonReply(nullptr) {}
  ~OmLogonReply() override;
  explicit constexpr OmLogonReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OmLogonReply(const OmLogonReply& from);
  OmLogonReply(OmLogonReply&& from) noexcept
    : OmLogonReply() {
    *this = ::std::move(from);
  }

  inline OmLogonReply& operator=(const OmLogonReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OmLogonReply& operator=(OmLogonReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OmLogonReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OmLogonReply* internal_default_instance() {
    return reinterpret_cast<const OmLogonReply*>(
               &_OmLogonReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OmLogonReply& a, OmLogonReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OmLogonReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OmLogonReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OmLogonReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OmLogonReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OmLogonReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OmLogonReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OmLogonReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.OmLogonReply";
  }
  protected:
  explicit OmLogonReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.OmLogonReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class SubscribeTicks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.SubscribeTicks) */ {
 public:
  inline SubscribeTicks() : SubscribeTicks(nullptr) {}
  ~SubscribeTicks() override;
  explicit constexpr SubscribeTicks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeTicks(const SubscribeTicks& from);
  SubscribeTicks(SubscribeTicks&& from) noexcept
    : SubscribeTicks() {
    *this = ::std::move(from);
  }

  inline SubscribeTicks& operator=(const SubscribeTicks& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeTicks& operator=(SubscribeTicks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeTicks& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeTicks* internal_default_instance() {
    return reinterpret_cast<const SubscribeTicks*>(
               &_SubscribeTicks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubscribeTicks& a, SubscribeTicks& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeTicks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeTicks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeTicks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeTicks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeTicks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeTicks& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeTicks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.SubscribeTicks";
  }
  protected:
  explicit SubscribeTicks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kExchangeFieldNumber = 2,
  };
  // string symbol = 1;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // .apex.pb.Exchange exchange = 2;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.SubscribeTicks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  int exchange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class SubscribeWallet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.SubscribeWallet) */ {
 public:
  inline SubscribeWallet() : SubscribeWallet(nullptr) {}
  ~SubscribeWallet() override;
  explicit constexpr SubscribeWallet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeWallet(const SubscribeWallet& from);
  SubscribeWallet(SubscribeWallet&& from) noexcept
    : SubscribeWallet() {
    *this = ::std::move(from);
  }

  inline SubscribeWallet& operator=(const SubscribeWallet& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeWallet& operator=(SubscribeWallet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeWallet& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeWallet* internal_default_instance() {
    return reinterpret_cast<const SubscribeWallet*>(
               &_SubscribeWallet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SubscribeWallet& a, SubscribeWallet& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeWallet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeWallet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeWallet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeWallet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeWallet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeWallet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeWallet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.SubscribeWallet";
  }
  protected:
  explicit SubscribeWallet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExchangeFieldNumber = 1,
  };
  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.SubscribeWallet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int exchange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class WalletUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.WalletUpdate) */ {
 public:
  inline WalletUpdate() : WalletUpdate(nullptr) {}
  ~WalletUpdate() override;
  explicit constexpr WalletUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalletUpdate(const WalletUpdate& from);
  WalletUpdate(WalletUpdate&& from) noexcept
    : WalletUpdate() {
    *this = ::std::move(from);
  }

  inline WalletUpdate& operator=(const WalletUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletUpdate& operator=(WalletUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalletUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalletUpdate* internal_default_instance() {
    return reinterpret_cast<const WalletUpdate*>(
               &_WalletUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WalletUpdate& a, WalletUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalletUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalletUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalletUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WalletUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.WalletUpdate";
  }
  protected:
  explicit WalletUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kPositionFieldNumber = 3,
    kExchangeFieldNumber = 1,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // double position = 3;
  void clear_position();
  double position() const;
  void set_position(double value);
  private:
  double _internal_position() const;
  void _internal_set_position(double value);
  public:

  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.WalletUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  double position_;
  int exchange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class TickTrade final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.TickTrade) */ {
 public:
  inline TickTrade() : TickTrade(nullptr) {}
  ~TickTrade() override;
  explicit constexpr TickTrade(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickTrade(const TickTrade& from);
  TickTrade(TickTrade&& from) noexcept
    : TickTrade() {
    *this = ::std::move(from);
  }

  inline TickTrade& operator=(const TickTrade& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickTrade& operator=(TickTrade&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickTrade& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickTrade* internal_default_instance() {
    return reinterpret_cast<const TickTrade*>(
               &_TickTrade_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TickTrade& a, TickTrade& b) {
    a.Swap(&b);
  }
  inline void Swap(TickTrade* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickTrade* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickTrade* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickTrade>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickTrade& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TickTrade& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickTrade* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.TickTrade";
  }
  protected:
  explicit TickTrade(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kPriceFieldNumber = 3,
    kExchangeFieldNumber = 1,
    kSideFieldNumber = 5,
    kSizeFieldNumber = 4,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // double price = 3;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // .apex.pb.Side side = 5;
  void clear_side();
  ::apex::pb::Side side() const;
  void set_side(::apex::pb::Side value);
  private:
  ::apex::pb::Side _internal_side() const;
  void _internal_set_side(::apex::pb::Side value);
  public:

  // double size = 4;
  void clear_size();
  double size() const;
  void set_size(double value);
  private:
  double _internal_size() const;
  void _internal_set_size(double value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.TickTrade)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  double price_;
  int exchange_;
  int side_;
  double size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class TickTop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.TickTop) */ {
 public:
  inline TickTop() : TickTop(nullptr) {}
  ~TickTop() override;
  explicit constexpr TickTop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TickTop(const TickTop& from);
  TickTop(TickTop&& from) noexcept
    : TickTop() {
    *this = ::std::move(from);
  }

  inline TickTop& operator=(const TickTop& from) {
    CopyFrom(from);
    return *this;
  }
  inline TickTop& operator=(TickTop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TickTop& default_instance() {
    return *internal_default_instance();
  }
  static inline const TickTop* internal_default_instance() {
    return reinterpret_cast<const TickTop*>(
               &_TickTop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TickTop& a, TickTop& b) {
    a.Swap(&b);
  }
  inline void Swap(TickTop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TickTop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TickTop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TickTop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TickTop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TickTop& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TickTop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.TickTop";
  }
  protected:
  explicit TickTop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kAskPriceFieldNumber = 3,
    kAskQtyFieldNumber = 4,
    kBidPriceFieldNumber = 5,
    kBidQtyFieldNumber = 6,
    kRtFieldNumber = 7,
    kExchangeFieldNumber = 1,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // double ask_price = 3;
  void clear_ask_price();
  double ask_price() const;
  void set_ask_price(double value);
  private:
  double _internal_ask_price() const;
  void _internal_set_ask_price(double value);
  public:

  // double ask_qty = 4;
  void clear_ask_qty();
  double ask_qty() const;
  void set_ask_qty(double value);
  private:
  double _internal_ask_qty() const;
  void _internal_set_ask_qty(double value);
  public:

  // double bid_price = 5;
  void clear_bid_price();
  double bid_price() const;
  void set_bid_price(double value);
  private:
  double _internal_bid_price() const;
  void _internal_set_bid_price(double value);
  public:

  // double bid_qty = 6;
  void clear_bid_qty();
  double bid_qty() const;
  void set_bid_qty(double value);
  private:
  double _internal_bid_qty() const;
  void _internal_set_bid_qty(double value);
  public:

  // uint64 rt = 7;
  void clear_rt();
  uint64_t rt() const;
  void set_rt(uint64_t value);
  private:
  uint64_t _internal_rt() const;
  void _internal_set_rt(uint64_t value);
  public:

  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.TickTop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  double ask_price_;
  double ask_qty_;
  double bid_price_;
  double bid_qty_;
  uint64_t rt_;
  int exchange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class NewOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.NewOrder) */ {
 public:
  inline NewOrder() : NewOrder(nullptr) {}
  ~NewOrder() override;
  explicit constexpr NewOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewOrder(const NewOrder& from);
  NewOrder(NewOrder&& from) noexcept
    : NewOrder() {
    *this = ::std::move(from);
  }

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewOrder& operator=(NewOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewOrder* internal_default_instance() {
    return reinterpret_cast<const NewOrder*>(
               &_NewOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NewOrder& a, NewOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(NewOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NewOrder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.NewOrder";
  }
  protected:
  explicit NewOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kOrderIdFieldNumber = 8,
    kPriceFieldNumber = 3,
    kExchangeFieldNumber = 1,
    kSideFieldNumber = 5,
    kSizeFieldNumber = 4,
    kTifFieldNumber = 6,
    kTypeFieldNumber = 7,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string order_id = 8;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // double price = 3;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // .apex.pb.Side side = 5;
  void clear_side();
  ::apex::pb::Side side() const;
  void set_side(::apex::pb::Side value);
  private:
  ::apex::pb::Side _internal_side() const;
  void _internal_set_side(::apex::pb::Side value);
  public:

  // double size = 4;
  void clear_size();
  double size() const;
  void set_size(double value);
  private:
  double _internal_size() const;
  void _internal_set_size(double value);
  public:

  // uint32 tif = 6;
  void clear_tif();
  uint32_t tif() const;
  void set_tif(uint32_t value);
  private:
  uint32_t _internal_tif() const;
  void _internal_set_tif(uint32_t value);
  public:

  // .apex.pb.OrderType type = 7;
  void clear_type();
  ::apex::pb::OrderType type() const;
  void set_type(::apex::pb::OrderType value);
  private:
  ::apex::pb::OrderType _internal_type() const;
  void _internal_set_type(::apex::pb::OrderType value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.NewOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
  double price_;
  int exchange_;
  int side_;
  double size_;
  uint32_t tif_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class OrderExecution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.OrderExecution) */ {
 public:
  inline OrderExecution() : OrderExecution(nullptr) {}
  ~OrderExecution() override;
  explicit constexpr OrderExecution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderExecution(const OrderExecution& from);
  OrderExecution(OrderExecution&& from) noexcept
    : OrderExecution() {
    *this = ::std::move(from);
  }

  inline OrderExecution& operator=(const OrderExecution& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderExecution& operator=(OrderExecution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderExecution& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderExecution* internal_default_instance() {
    return reinterpret_cast<const OrderExecution*>(
               &_OrderExecution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OrderExecution& a, OrderExecution& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderExecution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderExecution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderExecution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderExecution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderExecution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrderExecution& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderExecution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.OrderExecution";
  }
  protected:
  explicit OrderExecution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kExtOrderIdFieldNumber = 4,
    kOrderStateFieldNumber = 2,
    kCloseReasonFieldNumber = 3,
    kReasonFieldNumber = 5,
  };
  // string order_id = 1;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // string ext_order_id = 4;
  void clear_ext_order_id();
  const std::string& ext_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ext_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ext_order_id();
  PROTOBUF_NODISCARD std::string* release_ext_order_id();
  void set_allocated_ext_order_id(std::string* ext_order_id);
  private:
  const std::string& _internal_ext_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext_order_id(const std::string& value);
  std::string* _internal_mutable_ext_order_id();
  public:

  // uint32 order_state = 2;
  void clear_order_state();
  uint32_t order_state() const;
  void set_order_state(uint32_t value);
  private:
  uint32_t _internal_order_state() const;
  void _internal_set_order_state(uint32_t value);
  public:

  // uint32 close_reason = 3;
  void clear_close_reason();
  uint32_t close_reason() const;
  void set_close_reason(uint32_t value);
  private:
  uint32_t _internal_close_reason() const;
  void _internal_set_close_reason(uint32_t value);
  public:

  // .apex.pb.OrderUpdateReason reason = 5;
  void clear_reason();
  ::apex::pb::OrderUpdateReason reason() const;
  void set_reason(::apex::pb::OrderUpdateReason value);
  private:
  ::apex::pb::OrderUpdateReason _internal_reason() const;
  void _internal_set_reason(::apex::pb::OrderUpdateReason value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.OrderExecution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ext_order_id_;
  uint32_t order_state_;
  uint32_t close_reason_;
  int reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class CancelOrder final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.CancelOrder) */ {
 public:
  inline CancelOrder() : CancelOrder(nullptr) {}
  ~CancelOrder() override;
  explicit constexpr CancelOrder(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOrder(const CancelOrder& from);
  CancelOrder(CancelOrder&& from) noexcept
    : CancelOrder() {
    *this = ::std::move(from);
  }

  inline CancelOrder& operator=(const CancelOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrder& operator=(CancelOrder&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrder& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOrder* internal_default_instance() {
    return reinterpret_cast<const CancelOrder*>(
               &_CancelOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CancelOrder& a, CancelOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOrder* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOrder>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOrder& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelOrder& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrder* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.CancelOrder";
  }
  protected:
  explicit CancelOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kOrderIdFieldNumber = 3,
    kExtOrderIdFieldNumber = 4,
    kExchangeFieldNumber = 1,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string order_id = 3;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // string ext_order_id = 4;
  void clear_ext_order_id();
  const std::string& ext_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ext_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ext_order_id();
  PROTOBUF_NODISCARD std::string* release_ext_order_id();
  void set_allocated_ext_order_id(std::string* ext_order_id);
  private:
  const std::string& _internal_ext_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext_order_id(const std::string& value);
  std::string* _internal_mutable_ext_order_id();
  public:

  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.CancelOrder)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ext_order_id_;
  int exchange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class CancelOrderReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.CancelOrderReply) */ {
 public:
  inline CancelOrderReply() : CancelOrderReply(nullptr) {}
  ~CancelOrderReply() override;
  explicit constexpr CancelOrderReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelOrderReply(const CancelOrderReply& from);
  CancelOrderReply(CancelOrderReply&& from) noexcept
    : CancelOrderReply() {
    *this = ::std::move(from);
  }

  inline CancelOrderReply& operator=(const CancelOrderReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelOrderReply& operator=(CancelOrderReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelOrderReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelOrderReply* internal_default_instance() {
    return reinterpret_cast<const CancelOrderReply*>(
               &_CancelOrderReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CancelOrderReply& a, CancelOrderReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelOrderReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelOrderReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelOrderReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelOrderReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelOrderReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelOrderReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelOrderReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.CancelOrderReply";
  }
  protected:
  explicit CancelOrderReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderIdFieldNumber = 1,
    kExtOrderIdFieldNumber = 4,
    kOrderStateFieldNumber = 2,
    kCloseReasonFieldNumber = 3,
  };
  // string order_id = 1;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // string ext_order_id = 4;
  void clear_ext_order_id();
  const std::string& ext_order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ext_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ext_order_id();
  PROTOBUF_NODISCARD std::string* release_ext_order_id();
  void set_allocated_ext_order_id(std::string* ext_order_id);
  private:
  const std::string& _internal_ext_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ext_order_id(const std::string& value);
  std::string* _internal_mutable_ext_order_id();
  public:

  // uint32 order_state = 2;
  void clear_order_state();
  uint32_t order_state() const;
  void set_order_state(uint32_t value);
  private:
  uint32_t _internal_order_state() const;
  void _internal_set_order_state(uint32_t value);
  public:

  // uint32 close_reason = 3;
  void clear_close_reason();
  uint32_t close_reason() const;
  void set_close_reason(uint32_t value);
  private:
  uint32_t _internal_close_reason() const;
  void _internal_set_close_reason(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.CancelOrderReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ext_order_id_;
  uint32_t order_state_;
  uint32_t close_reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 2,
    kTextFieldNumber = 3,
    kOrigRequestTypeFieldNumber = 1,
  };
  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // uint32 orig_request_type = 1;
  void clear_orig_request_type();
  uint32_t orig_request_type() const;
  void set_orig_request_type(uint32_t value);
  private:
  uint32_t _internal_orig_request_type() const;
  void _internal_set_orig_request_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  uint32_t orig_request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// -------------------------------------------------------------------

class OrderFill final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apex.pb.OrderFill) */ {
 public:
  inline OrderFill() : OrderFill(nullptr) {}
  ~OrderFill() override;
  explicit constexpr OrderFill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderFill(const OrderFill& from);
  OrderFill(OrderFill&& from) noexcept
    : OrderFill() {
    *this = ::std::move(from);
  }

  inline OrderFill& operator=(const OrderFill& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderFill& operator=(OrderFill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderFill& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderFill* internal_default_instance() {
    return reinterpret_cast<const OrderFill*>(
               &_OrderFill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(OrderFill& a, OrderFill& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderFill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderFill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderFill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderFill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderFill& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrderFill& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderFill* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apex.pb.OrderFill";
  }
  protected:
  explicit OrderFill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kOrderIdFieldNumber = 3,
    kExchangeFieldNumber = 1,
    kFullyFilledFieldNumber = 6,
    kPriceFieldNumber = 4,
    kSizeFieldNumber = 5,
    kRecvTimeFieldNumber = 7,
  };
  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // string order_id = 3;
  void clear_order_id();
  const std::string& order_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order_id();
  PROTOBUF_NODISCARD std::string* release_order_id();
  void set_allocated_order_id(std::string* order_id);
  private:
  const std::string& _internal_order_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order_id(const std::string& value);
  std::string* _internal_mutable_order_id();
  public:

  // .apex.pb.Exchange exchange = 1;
  void clear_exchange();
  ::apex::pb::Exchange exchange() const;
  void set_exchange(::apex::pb::Exchange value);
  private:
  ::apex::pb::Exchange _internal_exchange() const;
  void _internal_set_exchange(::apex::pb::Exchange value);
  public:

  // bool fully_filled = 6;
  void clear_fully_filled();
  bool fully_filled() const;
  void set_fully_filled(bool value);
  private:
  bool _internal_fully_filled() const;
  void _internal_set_fully_filled(bool value);
  public:

  // double price = 4;
  void clear_price();
  double price() const;
  void set_price(double value);
  private:
  double _internal_price() const;
  void _internal_set_price(double value);
  public:

  // double size = 5;
  void clear_size();
  double size() const;
  void set_size(double value);
  private:
  double _internal_size() const;
  void _internal_set_size(double value);
  public:

  // uint64 recv_time = 7;
  void clear_recv_time();
  uint64_t recv_time() const;
  void set_recv_time(uint64_t value);
  private:
  uint64_t _internal_recv_time() const;
  void _internal_set_recv_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:apex.pb.OrderFill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_id_;
  int exchange_;
  bool fully_filled_;
  double price_;
  double size_;
  uint64_t recv_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GxWireFormat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogonRequest

// -------------------------------------------------------------------

// LogonReply

// string error = 1;
inline void LogonReply::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& LogonReply::error() const {
  // @@protoc_insertion_point(field_get:apex.pb.LogonReply.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogonReply::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.LogonReply.error)
}
inline std::string* LogonReply::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:apex.pb.LogonReply.error)
  return _s;
}
inline const std::string& LogonReply::_internal_error() const {
  return error_.Get();
}
inline void LogonReply::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogonReply::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogonReply::release_error() {
  // @@protoc_insertion_point(field_release:apex.pb.LogonReply.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LogonReply::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.LogonReply.error)
}

// -------------------------------------------------------------------

// OmLogonRequest

// .apex.pb.RunMode run_mode = 1;
inline void OmLogonRequest::clear_run_mode() {
  run_mode_ = 0;
}
inline ::apex::pb::RunMode OmLogonRequest::_internal_run_mode() const {
  return static_cast< ::apex::pb::RunMode >(run_mode_);
}
inline ::apex::pb::RunMode OmLogonRequest::run_mode() const {
  // @@protoc_insertion_point(field_get:apex.pb.OmLogonRequest.run_mode)
  return _internal_run_mode();
}
inline void OmLogonRequest::_internal_set_run_mode(::apex::pb::RunMode value) {
  
  run_mode_ = value;
}
inline void OmLogonRequest::set_run_mode(::apex::pb::RunMode value) {
  _internal_set_run_mode(value);
  // @@protoc_insertion_point(field_set:apex.pb.OmLogonRequest.run_mode)
}

// string strategy_id = 2;
inline void OmLogonRequest::clear_strategy_id() {
  strategy_id_.ClearToEmpty();
}
inline const std::string& OmLogonRequest::strategy_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.OmLogonRequest.strategy_id)
  return _internal_strategy_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OmLogonRequest::set_strategy_id(ArgT0&& arg0, ArgT... args) {
 
 strategy_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.OmLogonRequest.strategy_id)
}
inline std::string* OmLogonRequest::mutable_strategy_id() {
  std::string* _s = _internal_mutable_strategy_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.OmLogonRequest.strategy_id)
  return _s;
}
inline const std::string& OmLogonRequest::_internal_strategy_id() const {
  return strategy_id_.Get();
}
inline void OmLogonRequest::_internal_set_strategy_id(const std::string& value) {
  
  strategy_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OmLogonRequest::_internal_mutable_strategy_id() {
  
  return strategy_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OmLogonRequest::release_strategy_id() {
  // @@protoc_insertion_point(field_release:apex.pb.OmLogonRequest.strategy_id)
  return strategy_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OmLogonRequest::set_allocated_strategy_id(std::string* strategy_id) {
  if (strategy_id != nullptr) {
    
  } else {
    
  }
  strategy_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), strategy_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (strategy_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    strategy_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.OmLogonRequest.strategy_id)
}

// -------------------------------------------------------------------

// OmLogonReply

// string error = 1;
inline void OmLogonReply::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& OmLogonReply::error() const {
  // @@protoc_insertion_point(field_get:apex.pb.OmLogonReply.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OmLogonReply::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.OmLogonReply.error)
}
inline std::string* OmLogonReply::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:apex.pb.OmLogonReply.error)
  return _s;
}
inline const std::string& OmLogonReply::_internal_error() const {
  return error_.Get();
}
inline void OmLogonReply::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OmLogonReply::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OmLogonReply::release_error() {
  // @@protoc_insertion_point(field_release:apex.pb.OmLogonReply.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OmLogonReply::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.OmLogonReply.error)
}

// -------------------------------------------------------------------

// SubscribeTicks

// string symbol = 1;
inline void SubscribeTicks::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& SubscribeTicks::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.SubscribeTicks.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeTicks::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.SubscribeTicks.symbol)
}
inline std::string* SubscribeTicks::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.SubscribeTicks.symbol)
  return _s;
}
inline const std::string& SubscribeTicks::_internal_symbol() const {
  return symbol_.Get();
}
inline void SubscribeTicks::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeTicks::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeTicks::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.SubscribeTicks.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeTicks::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.SubscribeTicks.symbol)
}

// .apex.pb.Exchange exchange = 2;
inline void SubscribeTicks::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange SubscribeTicks::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange SubscribeTicks::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.SubscribeTicks.exchange)
  return _internal_exchange();
}
inline void SubscribeTicks::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void SubscribeTicks::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.SubscribeTicks.exchange)
}

// -------------------------------------------------------------------

// SubscribeWallet

// .apex.pb.Exchange exchange = 1;
inline void SubscribeWallet::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange SubscribeWallet::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange SubscribeWallet::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.SubscribeWallet.exchange)
  return _internal_exchange();
}
inline void SubscribeWallet::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void SubscribeWallet::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.SubscribeWallet.exchange)
}

// -------------------------------------------------------------------

// WalletUpdate

// .apex.pb.Exchange exchange = 1;
inline void WalletUpdate::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange WalletUpdate::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange WalletUpdate::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.WalletUpdate.exchange)
  return _internal_exchange();
}
inline void WalletUpdate::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void WalletUpdate::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.WalletUpdate.exchange)
}

// string symbol = 2;
inline void WalletUpdate::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& WalletUpdate::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.WalletUpdate.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletUpdate::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.WalletUpdate.symbol)
}
inline std::string* WalletUpdate::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.WalletUpdate.symbol)
  return _s;
}
inline const std::string& WalletUpdate::_internal_symbol() const {
  return symbol_.Get();
}
inline void WalletUpdate::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WalletUpdate::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WalletUpdate::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.WalletUpdate.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WalletUpdate::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.WalletUpdate.symbol)
}

// double position = 3;
inline void WalletUpdate::clear_position() {
  position_ = 0;
}
inline double WalletUpdate::_internal_position() const {
  return position_;
}
inline double WalletUpdate::position() const {
  // @@protoc_insertion_point(field_get:apex.pb.WalletUpdate.position)
  return _internal_position();
}
inline void WalletUpdate::_internal_set_position(double value) {
  
  position_ = value;
}
inline void WalletUpdate::set_position(double value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:apex.pb.WalletUpdate.position)
}

// -------------------------------------------------------------------

// TickTrade

// .apex.pb.Exchange exchange = 1;
inline void TickTrade::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange TickTrade::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange TickTrade::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTrade.exchange)
  return _internal_exchange();
}
inline void TickTrade::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void TickTrade::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTrade.exchange)
}

// string symbol = 2;
inline void TickTrade::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& TickTrade::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTrade.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TickTrade::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.TickTrade.symbol)
}
inline std::string* TickTrade::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.TickTrade.symbol)
  return _s;
}
inline const std::string& TickTrade::_internal_symbol() const {
  return symbol_.Get();
}
inline void TickTrade::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TickTrade::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TickTrade::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.TickTrade.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TickTrade::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.TickTrade.symbol)
}

// double price = 3;
inline void TickTrade::clear_price() {
  price_ = 0;
}
inline double TickTrade::_internal_price() const {
  return price_;
}
inline double TickTrade::price() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTrade.price)
  return _internal_price();
}
inline void TickTrade::_internal_set_price(double value) {
  
  price_ = value;
}
inline void TickTrade::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTrade.price)
}

// double size = 4;
inline void TickTrade::clear_size() {
  size_ = 0;
}
inline double TickTrade::_internal_size() const {
  return size_;
}
inline double TickTrade::size() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTrade.size)
  return _internal_size();
}
inline void TickTrade::_internal_set_size(double value) {
  
  size_ = value;
}
inline void TickTrade::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTrade.size)
}

// .apex.pb.Side side = 5;
inline void TickTrade::clear_side() {
  side_ = 0;
}
inline ::apex::pb::Side TickTrade::_internal_side() const {
  return static_cast< ::apex::pb::Side >(side_);
}
inline ::apex::pb::Side TickTrade::side() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTrade.side)
  return _internal_side();
}
inline void TickTrade::_internal_set_side(::apex::pb::Side value) {
  
  side_ = value;
}
inline void TickTrade::set_side(::apex::pb::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTrade.side)
}

// -------------------------------------------------------------------

// TickTop

// .apex.pb.Exchange exchange = 1;
inline void TickTop::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange TickTop::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange TickTop::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.exchange)
  return _internal_exchange();
}
inline void TickTop::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void TickTop::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.exchange)
}

// string symbol = 2;
inline void TickTop::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& TickTop::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TickTop::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.symbol)
}
inline std::string* TickTop::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.TickTop.symbol)
  return _s;
}
inline const std::string& TickTop::_internal_symbol() const {
  return symbol_.Get();
}
inline void TickTop::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TickTop::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TickTop::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.TickTop.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TickTop::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.TickTop.symbol)
}

// double ask_price = 3;
inline void TickTop::clear_ask_price() {
  ask_price_ = 0;
}
inline double TickTop::_internal_ask_price() const {
  return ask_price_;
}
inline double TickTop::ask_price() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.ask_price)
  return _internal_ask_price();
}
inline void TickTop::_internal_set_ask_price(double value) {
  
  ask_price_ = value;
}
inline void TickTop::set_ask_price(double value) {
  _internal_set_ask_price(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.ask_price)
}

// double ask_qty = 4;
inline void TickTop::clear_ask_qty() {
  ask_qty_ = 0;
}
inline double TickTop::_internal_ask_qty() const {
  return ask_qty_;
}
inline double TickTop::ask_qty() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.ask_qty)
  return _internal_ask_qty();
}
inline void TickTop::_internal_set_ask_qty(double value) {
  
  ask_qty_ = value;
}
inline void TickTop::set_ask_qty(double value) {
  _internal_set_ask_qty(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.ask_qty)
}

// double bid_price = 5;
inline void TickTop::clear_bid_price() {
  bid_price_ = 0;
}
inline double TickTop::_internal_bid_price() const {
  return bid_price_;
}
inline double TickTop::bid_price() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.bid_price)
  return _internal_bid_price();
}
inline void TickTop::_internal_set_bid_price(double value) {
  
  bid_price_ = value;
}
inline void TickTop::set_bid_price(double value) {
  _internal_set_bid_price(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.bid_price)
}

// double bid_qty = 6;
inline void TickTop::clear_bid_qty() {
  bid_qty_ = 0;
}
inline double TickTop::_internal_bid_qty() const {
  return bid_qty_;
}
inline double TickTop::bid_qty() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.bid_qty)
  return _internal_bid_qty();
}
inline void TickTop::_internal_set_bid_qty(double value) {
  
  bid_qty_ = value;
}
inline void TickTop::set_bid_qty(double value) {
  _internal_set_bid_qty(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.bid_qty)
}

// uint64 rt = 7;
inline void TickTop::clear_rt() {
  rt_ = uint64_t{0u};
}
inline uint64_t TickTop::_internal_rt() const {
  return rt_;
}
inline uint64_t TickTop::rt() const {
  // @@protoc_insertion_point(field_get:apex.pb.TickTop.rt)
  return _internal_rt();
}
inline void TickTop::_internal_set_rt(uint64_t value) {
  
  rt_ = value;
}
inline void TickTop::set_rt(uint64_t value) {
  _internal_set_rt(value);
  // @@protoc_insertion_point(field_set:apex.pb.TickTop.rt)
}

// -------------------------------------------------------------------

// NewOrder

// .apex.pb.Exchange exchange = 1;
inline void NewOrder::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange NewOrder::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange NewOrder::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.exchange)
  return _internal_exchange();
}
inline void NewOrder::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void NewOrder::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.exchange)
}

// string symbol = 2;
inline void NewOrder::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& NewOrder::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewOrder::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.symbol)
}
inline std::string* NewOrder::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.NewOrder.symbol)
  return _s;
}
inline const std::string& NewOrder::_internal_symbol() const {
  return symbol_.Get();
}
inline void NewOrder::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NewOrder::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NewOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.NewOrder.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NewOrder::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.NewOrder.symbol)
}

// double price = 3;
inline void NewOrder::clear_price() {
  price_ = 0;
}
inline double NewOrder::_internal_price() const {
  return price_;
}
inline double NewOrder::price() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.price)
  return _internal_price();
}
inline void NewOrder::_internal_set_price(double value) {
  
  price_ = value;
}
inline void NewOrder::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.price)
}

// double size = 4;
inline void NewOrder::clear_size() {
  size_ = 0;
}
inline double NewOrder::_internal_size() const {
  return size_;
}
inline double NewOrder::size() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.size)
  return _internal_size();
}
inline void NewOrder::_internal_set_size(double value) {
  
  size_ = value;
}
inline void NewOrder::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.size)
}

// .apex.pb.Side side = 5;
inline void NewOrder::clear_side() {
  side_ = 0;
}
inline ::apex::pb::Side NewOrder::_internal_side() const {
  return static_cast< ::apex::pb::Side >(side_);
}
inline ::apex::pb::Side NewOrder::side() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.side)
  return _internal_side();
}
inline void NewOrder::_internal_set_side(::apex::pb::Side value) {
  
  side_ = value;
}
inline void NewOrder::set_side(::apex::pb::Side value) {
  _internal_set_side(value);
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.side)
}

// uint32 tif = 6;
inline void NewOrder::clear_tif() {
  tif_ = 0u;
}
inline uint32_t NewOrder::_internal_tif() const {
  return tif_;
}
inline uint32_t NewOrder::tif() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.tif)
  return _internal_tif();
}
inline void NewOrder::_internal_set_tif(uint32_t value) {
  
  tif_ = value;
}
inline void NewOrder::set_tif(uint32_t value) {
  _internal_set_tif(value);
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.tif)
}

// .apex.pb.OrderType type = 7;
inline void NewOrder::clear_type() {
  type_ = 0;
}
inline ::apex::pb::OrderType NewOrder::_internal_type() const {
  return static_cast< ::apex::pb::OrderType >(type_);
}
inline ::apex::pb::OrderType NewOrder::type() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.type)
  return _internal_type();
}
inline void NewOrder::_internal_set_type(::apex::pb::OrderType value) {
  
  type_ = value;
}
inline void NewOrder::set_type(::apex::pb::OrderType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.type)
}

// string order_id = 8;
inline void NewOrder::clear_order_id() {
  order_id_.ClearToEmpty();
}
inline const std::string& NewOrder::order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.NewOrder.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewOrder::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.NewOrder.order_id)
}
inline std::string* NewOrder::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.NewOrder.order_id)
  return _s;
}
inline const std::string& NewOrder::_internal_order_id() const {
  return order_id_.Get();
}
inline void NewOrder::_internal_set_order_id(const std::string& value) {
  
  order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NewOrder::_internal_mutable_order_id() {
  
  return order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NewOrder::release_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.NewOrder.order_id)
  return order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NewOrder::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.NewOrder.order_id)
}

// -------------------------------------------------------------------

// OrderExecution

// string order_id = 1;
inline void OrderExecution::clear_order_id() {
  order_id_.ClearToEmpty();
}
inline const std::string& OrderExecution::order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderExecution.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderExecution::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.OrderExecution.order_id)
}
inline std::string* OrderExecution::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.OrderExecution.order_id)
  return _s;
}
inline const std::string& OrderExecution::_internal_order_id() const {
  return order_id_.Get();
}
inline void OrderExecution::_internal_set_order_id(const std::string& value) {
  
  order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OrderExecution::_internal_mutable_order_id() {
  
  return order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OrderExecution::release_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.OrderExecution.order_id)
  return order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OrderExecution::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.OrderExecution.order_id)
}

// uint32 order_state = 2;
inline void OrderExecution::clear_order_state() {
  order_state_ = 0u;
}
inline uint32_t OrderExecution::_internal_order_state() const {
  return order_state_;
}
inline uint32_t OrderExecution::order_state() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderExecution.order_state)
  return _internal_order_state();
}
inline void OrderExecution::_internal_set_order_state(uint32_t value) {
  
  order_state_ = value;
}
inline void OrderExecution::set_order_state(uint32_t value) {
  _internal_set_order_state(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderExecution.order_state)
}

// uint32 close_reason = 3;
inline void OrderExecution::clear_close_reason() {
  close_reason_ = 0u;
}
inline uint32_t OrderExecution::_internal_close_reason() const {
  return close_reason_;
}
inline uint32_t OrderExecution::close_reason() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderExecution.close_reason)
  return _internal_close_reason();
}
inline void OrderExecution::_internal_set_close_reason(uint32_t value) {
  
  close_reason_ = value;
}
inline void OrderExecution::set_close_reason(uint32_t value) {
  _internal_set_close_reason(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderExecution.close_reason)
}

// string ext_order_id = 4;
inline void OrderExecution::clear_ext_order_id() {
  ext_order_id_.ClearToEmpty();
}
inline const std::string& OrderExecution::ext_order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderExecution.ext_order_id)
  return _internal_ext_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderExecution::set_ext_order_id(ArgT0&& arg0, ArgT... args) {
 
 ext_order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.OrderExecution.ext_order_id)
}
inline std::string* OrderExecution::mutable_ext_order_id() {
  std::string* _s = _internal_mutable_ext_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.OrderExecution.ext_order_id)
  return _s;
}
inline const std::string& OrderExecution::_internal_ext_order_id() const {
  return ext_order_id_.Get();
}
inline void OrderExecution::_internal_set_ext_order_id(const std::string& value) {
  
  ext_order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OrderExecution::_internal_mutable_ext_order_id() {
  
  return ext_order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OrderExecution::release_ext_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.OrderExecution.ext_order_id)
  return ext_order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OrderExecution::set_allocated_ext_order_id(std::string* ext_order_id) {
  if (ext_order_id != nullptr) {
    
  } else {
    
  }
  ext_order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ext_order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ext_order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ext_order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.OrderExecution.ext_order_id)
}

// .apex.pb.OrderUpdateReason reason = 5;
inline void OrderExecution::clear_reason() {
  reason_ = 0;
}
inline ::apex::pb::OrderUpdateReason OrderExecution::_internal_reason() const {
  return static_cast< ::apex::pb::OrderUpdateReason >(reason_);
}
inline ::apex::pb::OrderUpdateReason OrderExecution::reason() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderExecution.reason)
  return _internal_reason();
}
inline void OrderExecution::_internal_set_reason(::apex::pb::OrderUpdateReason value) {
  
  reason_ = value;
}
inline void OrderExecution::set_reason(::apex::pb::OrderUpdateReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderExecution.reason)
}

// -------------------------------------------------------------------

// CancelOrder

// .apex.pb.Exchange exchange = 1;
inline void CancelOrder::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange CancelOrder::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange CancelOrder::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrder.exchange)
  return _internal_exchange();
}
inline void CancelOrder::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void CancelOrder::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrder.exchange)
}

// string symbol = 2;
inline void CancelOrder::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& CancelOrder::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrder.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrder::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrder.symbol)
}
inline std::string* CancelOrder::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.CancelOrder.symbol)
  return _s;
}
inline const std::string& CancelOrder::_internal_symbol() const {
  return symbol_.Get();
}
inline void CancelOrder::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOrder::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.CancelOrder.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOrder::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.CancelOrder.symbol)
}

// string order_id = 3;
inline void CancelOrder::clear_order_id() {
  order_id_.ClearToEmpty();
}
inline const std::string& CancelOrder::order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrder.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrder::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrder.order_id)
}
inline std::string* CancelOrder::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.CancelOrder.order_id)
  return _s;
}
inline const std::string& CancelOrder::_internal_order_id() const {
  return order_id_.Get();
}
inline void CancelOrder::_internal_set_order_id(const std::string& value) {
  
  order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOrder::_internal_mutable_order_id() {
  
  return order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOrder::release_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.CancelOrder.order_id)
  return order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOrder::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.CancelOrder.order_id)
}

// string ext_order_id = 4;
inline void CancelOrder::clear_ext_order_id() {
  ext_order_id_.ClearToEmpty();
}
inline const std::string& CancelOrder::ext_order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrder.ext_order_id)
  return _internal_ext_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrder::set_ext_order_id(ArgT0&& arg0, ArgT... args) {
 
 ext_order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrder.ext_order_id)
}
inline std::string* CancelOrder::mutable_ext_order_id() {
  std::string* _s = _internal_mutable_ext_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.CancelOrder.ext_order_id)
  return _s;
}
inline const std::string& CancelOrder::_internal_ext_order_id() const {
  return ext_order_id_.Get();
}
inline void CancelOrder::_internal_set_ext_order_id(const std::string& value) {
  
  ext_order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOrder::_internal_mutable_ext_order_id() {
  
  return ext_order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOrder::release_ext_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.CancelOrder.ext_order_id)
  return ext_order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOrder::set_allocated_ext_order_id(std::string* ext_order_id) {
  if (ext_order_id != nullptr) {
    
  } else {
    
  }
  ext_order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ext_order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ext_order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ext_order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.CancelOrder.ext_order_id)
}

// -------------------------------------------------------------------

// CancelOrderReply

// string order_id = 1;
inline void CancelOrderReply::clear_order_id() {
  order_id_.ClearToEmpty();
}
inline const std::string& CancelOrderReply::order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrderReply.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrderReply::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrderReply.order_id)
}
inline std::string* CancelOrderReply::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.CancelOrderReply.order_id)
  return _s;
}
inline const std::string& CancelOrderReply::_internal_order_id() const {
  return order_id_.Get();
}
inline void CancelOrderReply::_internal_set_order_id(const std::string& value) {
  
  order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOrderReply::_internal_mutable_order_id() {
  
  return order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOrderReply::release_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.CancelOrderReply.order_id)
  return order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOrderReply::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.CancelOrderReply.order_id)
}

// uint32 order_state = 2;
inline void CancelOrderReply::clear_order_state() {
  order_state_ = 0u;
}
inline uint32_t CancelOrderReply::_internal_order_state() const {
  return order_state_;
}
inline uint32_t CancelOrderReply::order_state() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrderReply.order_state)
  return _internal_order_state();
}
inline void CancelOrderReply::_internal_set_order_state(uint32_t value) {
  
  order_state_ = value;
}
inline void CancelOrderReply::set_order_state(uint32_t value) {
  _internal_set_order_state(value);
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrderReply.order_state)
}

// uint32 close_reason = 3;
inline void CancelOrderReply::clear_close_reason() {
  close_reason_ = 0u;
}
inline uint32_t CancelOrderReply::_internal_close_reason() const {
  return close_reason_;
}
inline uint32_t CancelOrderReply::close_reason() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrderReply.close_reason)
  return _internal_close_reason();
}
inline void CancelOrderReply::_internal_set_close_reason(uint32_t value) {
  
  close_reason_ = value;
}
inline void CancelOrderReply::set_close_reason(uint32_t value) {
  _internal_set_close_reason(value);
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrderReply.close_reason)
}

// string ext_order_id = 4;
inline void CancelOrderReply::clear_ext_order_id() {
  ext_order_id_.ClearToEmpty();
}
inline const std::string& CancelOrderReply::ext_order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.CancelOrderReply.ext_order_id)
  return _internal_ext_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CancelOrderReply::set_ext_order_id(ArgT0&& arg0, ArgT... args) {
 
 ext_order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.CancelOrderReply.ext_order_id)
}
inline std::string* CancelOrderReply::mutable_ext_order_id() {
  std::string* _s = _internal_mutable_ext_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.CancelOrderReply.ext_order_id)
  return _s;
}
inline const std::string& CancelOrderReply::_internal_ext_order_id() const {
  return ext_order_id_.Get();
}
inline void CancelOrderReply::_internal_set_ext_order_id(const std::string& value) {
  
  ext_order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CancelOrderReply::_internal_mutable_ext_order_id() {
  
  return ext_order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CancelOrderReply::release_ext_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.CancelOrderReply.ext_order_id)
  return ext_order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CancelOrderReply::set_allocated_ext_order_id(std::string* ext_order_id) {
  if (ext_order_id != nullptr) {
    
  } else {
    
  }
  ext_order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ext_order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ext_order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ext_order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.CancelOrderReply.ext_order_id)
}

// -------------------------------------------------------------------

// Error

// uint32 orig_request_type = 1;
inline void Error::clear_orig_request_type() {
  orig_request_type_ = 0u;
}
inline uint32_t Error::_internal_orig_request_type() const {
  return orig_request_type_;
}
inline uint32_t Error::orig_request_type() const {
  // @@protoc_insertion_point(field_get:apex.pb.Error.orig_request_type)
  return _internal_orig_request_type();
}
inline void Error::_internal_set_orig_request_type(uint32_t value) {
  
  orig_request_type_ = value;
}
inline void Error::set_orig_request_type(uint32_t value) {
  _internal_set_orig_request_type(value);
  // @@protoc_insertion_point(field_set:apex.pb.Error.orig_request_type)
}

// string code = 2;
inline void Error::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Error::code() const {
  // @@protoc_insertion_point(field_get:apex.pb.Error.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.Error.code)
}
inline std::string* Error::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:apex.pb.Error.code)
  return _s;
}
inline const std::string& Error::_internal_code() const {
  return code_.Get();
}
inline void Error::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_code() {
  // @@protoc_insertion_point(field_release:apex.pb.Error.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.Error.code)
}

// string text = 3;
inline void Error::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& Error::text() const {
  // @@protoc_insertion_point(field_get:apex.pb.Error.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.Error.text)
}
inline std::string* Error::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:apex.pb.Error.text)
  return _s;
}
inline const std::string& Error::_internal_text() const {
  return text_.Get();
}
inline void Error::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_text() {
  // @@protoc_insertion_point(field_release:apex.pb.Error.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.Error.text)
}

// -------------------------------------------------------------------

// OrderFill

// .apex.pb.Exchange exchange = 1;
inline void OrderFill::clear_exchange() {
  exchange_ = 0;
}
inline ::apex::pb::Exchange OrderFill::_internal_exchange() const {
  return static_cast< ::apex::pb::Exchange >(exchange_);
}
inline ::apex::pb::Exchange OrderFill::exchange() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.exchange)
  return _internal_exchange();
}
inline void OrderFill::_internal_set_exchange(::apex::pb::Exchange value) {
  
  exchange_ = value;
}
inline void OrderFill::set_exchange(::apex::pb::Exchange value) {
  _internal_set_exchange(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.exchange)
}

// string symbol = 2;
inline void OrderFill::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& OrderFill::symbol() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderFill::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.symbol)
}
inline std::string* OrderFill::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:apex.pb.OrderFill.symbol)
  return _s;
}
inline const std::string& OrderFill::_internal_symbol() const {
  return symbol_.Get();
}
inline void OrderFill::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OrderFill::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OrderFill::release_symbol() {
  // @@protoc_insertion_point(field_release:apex.pb.OrderFill.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OrderFill::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.OrderFill.symbol)
}

// string order_id = 3;
inline void OrderFill::clear_order_id() {
  order_id_.ClearToEmpty();
}
inline const std::string& OrderFill::order_id() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.order_id)
  return _internal_order_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OrderFill::set_order_id(ArgT0&& arg0, ArgT... args) {
 
 order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.order_id)
}
inline std::string* OrderFill::mutable_order_id() {
  std::string* _s = _internal_mutable_order_id();
  // @@protoc_insertion_point(field_mutable:apex.pb.OrderFill.order_id)
  return _s;
}
inline const std::string& OrderFill::_internal_order_id() const {
  return order_id_.Get();
}
inline void OrderFill::_internal_set_order_id(const std::string& value) {
  
  order_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OrderFill::_internal_mutable_order_id() {
  
  return order_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OrderFill::release_order_id() {
  // @@protoc_insertion_point(field_release:apex.pb.OrderFill.order_id)
  return order_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OrderFill::set_allocated_order_id(std::string* order_id) {
  if (order_id != nullptr) {
    
  } else {
    
  }
  order_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:apex.pb.OrderFill.order_id)
}

// double price = 4;
inline void OrderFill::clear_price() {
  price_ = 0;
}
inline double OrderFill::_internal_price() const {
  return price_;
}
inline double OrderFill::price() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.price)
  return _internal_price();
}
inline void OrderFill::_internal_set_price(double value) {
  
  price_ = value;
}
inline void OrderFill::set_price(double value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.price)
}

// double size = 5;
inline void OrderFill::clear_size() {
  size_ = 0;
}
inline double OrderFill::_internal_size() const {
  return size_;
}
inline double OrderFill::size() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.size)
  return _internal_size();
}
inline void OrderFill::_internal_set_size(double value) {
  
  size_ = value;
}
inline void OrderFill::set_size(double value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.size)
}

// bool fully_filled = 6;
inline void OrderFill::clear_fully_filled() {
  fully_filled_ = false;
}
inline bool OrderFill::_internal_fully_filled() const {
  return fully_filled_;
}
inline bool OrderFill::fully_filled() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.fully_filled)
  return _internal_fully_filled();
}
inline void OrderFill::_internal_set_fully_filled(bool value) {
  
  fully_filled_ = value;
}
inline void OrderFill::set_fully_filled(bool value) {
  _internal_set_fully_filled(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.fully_filled)
}

// uint64 recv_time = 7;
inline void OrderFill::clear_recv_time() {
  recv_time_ = uint64_t{0u};
}
inline uint64_t OrderFill::_internal_recv_time() const {
  return recv_time_;
}
inline uint64_t OrderFill::recv_time() const {
  // @@protoc_insertion_point(field_get:apex.pb.OrderFill.recv_time)
  return _internal_recv_time();
}
inline void OrderFill::_internal_set_recv_time(uint64_t value) {
  
  recv_time_ = value;
}
inline void OrderFill::set_recv_time(uint64_t value) {
  _internal_set_recv_time(value);
  // @@protoc_insertion_point(field_set:apex.pb.OrderFill.recv_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace apex

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apex::pb::Side> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::Side>() {
  return ::apex::pb::Side_descriptor();
}
template <> struct is_proto_enum< ::apex::pb::Exchange> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::Exchange>() {
  return ::apex::pb::Exchange_descriptor();
}
template <> struct is_proto_enum< ::apex::pb::RunMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::RunMode>() {
  return ::apex::pb::RunMode_descriptor();
}
template <> struct is_proto_enum< ::apex::pb::OrderState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::OrderState>() {
  return ::apex::pb::OrderState_descriptor();
}
template <> struct is_proto_enum< ::apex::pb::CloseReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::CloseReason>() {
  return ::apex::pb::CloseReason_descriptor();
}
template <> struct is_proto_enum< ::apex::pb::OrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::OrderType>() {
  return ::apex::pb::OrderType_descriptor();
}
template <> struct is_proto_enum< ::apex::pb::OrderUpdateReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apex::pb::OrderUpdateReason>() {
  return ::apex::pb::OrderUpdateReason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_GxWireFormat_2eproto
